name: Build & Release (Windows EXE)

on:
  push:
    branches: [ main ]
    paths:
      - "Version.json"
      - "scripts/**"
      - "**/*.py"
      - "resources/requirements.txt"
      - ".github/workflows/release.yml"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-release:
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"
          cache: "pip"
          cache-dependency-path: "resources/requirements.txt"

      - name: Create venv
        shell: pwsh
        run: |
          python -m venv .venv
          .\.venv\Scripts\python -m pip install --upgrade pip

      - name: Install project dependencies + PyInstaller
        shell: pwsh
        run: |
          if (-not (Test-Path "resources/requirements.txt")) { throw "resources/requirements.txt not found" }
          .\.venv\Scripts\python -m pip install --upgrade --prefer-binary -r resources/requirements.txt
          .\.venv\Scripts\python -m pip install --upgrade pyinstaller
          .\.venv\Scripts\python -m pip check
          .\.venv\Scripts\python -m pip freeze | Out-File -FilePath pip-freeze.txt -Encoding utf8

      - name: Upload pip freeze (debug)
        uses: actions/upload-artifact@v4
        with:
          name: pip-freeze
          path: pip-freeze.txt

      - name: Read version from Version.json
        id: version
        shell: pwsh
        run: |
          if (-not (Test-Path "Version.json")) { throw "Version.json not found" }
          $json = Get-Content Version.json -Raw | ConvertFrom-Json
          $ver  = $json.'modding-tool-version'
          if (-not $ver) { throw "Key 'modding-tool-version' not found in Version.json" }
          "version=$ver" >> $env:GITHUB_OUTPUT
          Write-Host "Detected version: $ver"

      - name: Get latest release tag (if any)
        id: latest
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { data } = await github.rest.repos.getLatestRelease({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              core.setOutput('tag', data.tag_name || '');
            } catch (e) {
              core.setOutput('tag', '');
            }

      - name: Decide if version bumped
        id: decide
        shell: pwsh
        run: |
          $want = "v${{ steps.version.outputs.version }}"
          $latest = "${{ steps.latest.outputs.tag }}"
          Write-Host "Latest release tag: '$latest'"
          Write-Host "Desired tag:         '$want'"
          if ($latest -eq $want) {
            "changed=no" >> $env:GITHUB_OUTPUT
            Write-Host "No version bump; skipping build + release."
          } else {
            "changed=yes" >> $env:GITHUB_OUTPUT
            "tag=$want"   >> $env:GITHUB_OUTPUT
            Write-Host "Version bump detected; will build + release."
          }

      # Build using the venv; ensure pyinstaller is found in this same cmd process
      - name: Build EXE (scripts\Package.bat) using venv
        if: steps.decide.outputs.changed == 'yes'
        shell: cmd
        run: |
          setlocal enabledelayedexpansion
          set "VENV_SCRIPTS=%CD%\.venv\Scripts"
          if not exist "%VENV_SCRIPTS%\pyinstaller.exe" (
            echo [ERROR] PyInstaller not found at "%VENV_SCRIPTS%\pyinstaller.exe"
            dir "%VENV_SCRIPTS%"
            exit /b 1
          )
          echo [INFO] Using venv: "%VENV_SCRIPTS%"
          set "PATH=%VENV_SCRIPTS%;%PATH%"
          where python
          where pip
          where pyinstaller
          python --version
          pip --version
          rem Use the venv's Python in your packaging script; inside your BAT prefer:  python -m PyInstaller ...
          call .\scripts\Package.bat
          if errorlevel 1 (
            echo [ERROR] Package.bat returned errorlevel %errorlevel%
            exit /b %errorlevel%
          )

      - name: Verify build output and show tree on failure
        if: steps.decide.outputs.changed == 'yes'
        shell: pwsh
        run: |
          if (-not (Test-Path "dist")) {
            Write-Host "dist folder not found â€” showing workspace tree for debugging:"
            Get-ChildItem -Recurse -File | Select-Object FullName, Length, LastWriteTime | Sort-Object LastWriteTime -Descending | Select-Object -First 200 | Format-Table -AutoSize
            throw "dist folder not found"
          }

      - name: Find built EXE (in dist/)
        if: steps.decide.outputs.changed == 'yes'
        id: find_exe
        shell: pwsh
        run: |
          $exe = Get-ChildItem -Path dist -Filter *.exe -Recurse | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          if (-not $exe) { throw "No .exe found under dist" }
          "exe_path=$($exe.FullName)" >> $env:GITHUB_OUTPUT
          "exe_name=$($exe.BaseName)" >> $env:GITHUB_OUTPUT
          Write-Host "Found EXE: $($exe.FullName)"

      - name: Prepare EXE asset (versioned filename)
        if: steps.decide.outputs.changed == 'yes'
        id: asset
        shell: pwsh
        run: |
          $assetName = "${{ steps.find_exe.outputs.exe_name }}-v${{ steps.version.outputs.version }}-win.exe"
          $dest = Join-Path $pwd $assetName
          Copy-Item -Path "${{ steps.find_exe.outputs.exe_path }}" -Destination $dest -Force
          "asset_path=$dest" >> $env:GITHUB_OUTPUT
          Write-Host "Prepared asset: $dest"

      - name: Create GitHub Release (upload EXE directly)
        if: steps.decide.outputs.changed == 'yes'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.decide.outputs.tag }}
          name: "Convai Modding Tool ${{ steps.version.outputs.version }}"
          body: |
            Automated release built on Windows runner.
            - Version: `${{ steps.version.outputs.version }}`
            - Built from commit: `${{ github.sha }}`
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, '-') }}
          files: ${{ steps.asset.outputs.asset_path }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
